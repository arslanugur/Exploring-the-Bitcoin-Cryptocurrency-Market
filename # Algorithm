Primitive     --->              : Integer, Boolean, String, Float
Non-Primitive ---> Built-In     : List, Set, Dictionary, Tuple
              ---> User-Defined : Stack, Queue, Tree, Linked List, Graph



> DATA STRUCTURES
             Primitive Data Structures (Build-in, System or Compiler Defined)
                  -->  int, char, float, pointer.. 
                  
                  -->  boolean: boolean
                  -->  numeric: character: char
                                integral: integer: byte, short, int, long
                                          floating-point: float, double 

         Non-Primitive Data Structures (User Defined)
                  -->  Array, List, Files, String, Structure, Classes
                               |
1. Linear Data Structures      |  2. Non-Linear Data Structures
   - Arrays                    |     - Trees
                               |          - Binary Tree
   - Linked Lists              |     - Graphs
   - Stacks                    |     - (Hash) Tables
   - Queues                    |     - Sets
   - Files                     |     - Tries
                                     - Matrix
                                     - Sparse Matrix
                                     - Heap
                                      


# Operations with Data Structures
    1. Traversing:  Visiting each elements of the data structure only once is called traversing
    2. Searching:   Finding an element in a data structure that satisfies one or more conditions
    3. Access:
    4. Inserting:   Adding elements of the same type in a data structure is called inserting. Elements can be added anywhere in the DS
    5. Deleting:    Removing an element from a data structure is called deletion. Elements can be removed from anywhere in the DS
    6. Sorting:     Sorting the elements in a data structure in ascending and descending order is called sorting
    7. Merging:     Merging is the storage of elements located in two different files by combining them into one data file



> ALGORITHMS with DS
# Data Structures
Arrays
    - Kadane's Algorithm (Max Subarray Problem)
    - Floyd's Cycle Detection Algorithm (Floyd's Tortoise and Hare)
    - KMP(Knuth-Morris-Pratt) Algorithm - Class: String Search Algorithms, DS: String
    - Quickselect Algorithm
    - Boyer-Moore Majority Vote (BMMV) Algorithm
    - Sorting Algorithms Class

Graphs
  Applications:
    - To define flow of computation
    - In WWW, web pages are considered to be the vertices
  Common Interview Questions:
    - Find shortest path between two vertices
    - Check if a path exists between two vertices
    - Find "Mother Vertex" in a graph
    - Check if a graph is a tree or not
  Algorithms:
    - Kruskal's Algorithm
    - Dijkstra's Algorithm
    - Bellman Ford Algorithm
    - Floyd-Warshall Algorithm (to find shortest paths), All-Pairs Shortest Path Problem for weighted graphs
    - Topological Sort Algorithm
    - Flood Fill Algorithm
    - Lee Algorithm


Linked Lists
  Applications:
    - Implement stacks, queues, and hash tables
    - Create directories
    - Dynamic memory allocation
  Common Interview Questions:
    - Reverse a linked list 
    - Detect loop in a linked list
    - Find the middle value in a linked list
    - Remove loop in a linked list

Stacks
  Applications:
    - Backtracking to a previous state
    - Expression evalution and conversion
    - Used for Memory Management
  Common Interview Questions:
    - Use stack to check for balanced parenthesis
    - iInplement two stacks in an array
    - Next greater element using a stack
    - Convert infix to postfix using stack
    
Queues
  Applications:
    - To reverse strings
    - To traverse the nodes of a binary tree
    - To search the vertices of a graph
  Common Interview Questions:
    - Reverse first kth elements of a queue 
    - Generate binary numbers from 1 to n using a queue
    - Implement stack using a queue
    
Hash Tables
  Applications:
    - When a resource is shared by multiple customers
    - Password verification
    - Linking file name and path
  Common Interview Questions:
    - Find symmetric pairs in an array 
    - Union and Intersection of lists using Hashing
    - Find a pair with given sum
    - Find the largest subarray with 0 sum
    
    
    


# Topic Wise Importance
    1. Concepts
        Big O Notations
        Memory
        Logarithm
        Recursion
    
    2. Data Structures
            A DS is way of organizing and holding data in some manner in an efficient way 
            so that it can be accessed, queried or even updated easily and quickly.
        Array
        Linked List
        Stack
        Queue
        Hash Tables
        Trees
        Heaps
        Tries
        Graph


Array Example in C              # a collection of (self-indexed from 0) elements of the same data types are stored contiguous memory locations
----------------------------
#include <stdio.h>

int main()
{
    int arr[] = {1,2,3,4,5};
    printf("%d", arr[3]);
    return 0;
    }
----------------------------
        
        
        
    3. Algorithms           (performs over data structures)
        Sorting algorithm   a set of steps to search
        Searching           a set of steps to sort in some order
        Tree Traversal
        Graph Traversal
        Arrays




# ARRAYS ALGORITHMS
    - Kadane's Algorithm
    - Floyd's Cycle Detection Algorithm
    - KMP Algorithm
    - Quick Select Algorithm
    - Boyer-More Majority Vote Algorithm








# SORTING ALGORITHMS
    In sort algorithms, idea is to arrange the items of a list in a specific order.
    - Insertion Sort
    - Selection Sort
    - Merge Sort
    - Quick Sort
    - Bucket Sort
    - Heap Sort
    - Counting Sort




# Searching & Sorting: order statistics, KMP algo, Rabin Karp, Z's Algo, Aho Corasick String Matching, Manacher's algo



    

# SEARCHING ALGORITHMS
    Find a element in a data set. There are 2 types of search algorithms
    - Linear Search
    - Binary Search           # Method: Divide and Conquer
                for Linear Data Structures
----------------------------
def BinarySearch(lys, val):
    first = 0
    last = len(lys)-1
    index = -1
    while (first <= last) and (index == -1):
        mid = (first+last)//2
        if lys[mid] == val:
            index = mid
        else:
            if val<lys[mid]:
                last = mid -1
            else:
                first = mid +1
    return index

index = BinarySearch([1,2,3,4,5,6,7,8,9,10], 7)
print(index)
----------------------------
    - Depth First Search  (for Graph Data Structures)
    - Breath First Search (for Graph Data Structures)
    - Rabin Karp
    - KMP Algo
    - Z's Algo
    - Aho Corasick String Matching
    - Manacher's Algo
    






# GRAPH ALGORITHMS
    - Minimum Spanning Tree (Prim's Algorithm)
    - Minimum Spanning Tree (Kruskal's Algorithm)
    - Shortest Path from every vertex to every other vertex (Dijkstra's Algorithm)
    - Shortest Path from source to all vertices (Floyd Warshall Algorithm)
    - Bellman Ford Algorithm
    - Topological Sort Algorithm
    - Flood Fill Algorithm
    - Lee Algorithm
    - Breadth First Search (BFS)
    - Depth First Search (DFS)
    - Johnson's Algo
    - Bridges in a graph
    - Articulation Points (or Cut Verticals) in a graph






   
# HASHING ALGORITHMS
    Hashing lookup is currently the most widely used technique to find appropriate data by key or ID. We access data by its index.







# ALGORITHM TECHNIQUES
# DYNAMIC PROGRAMMING ALGORITHMS
    DP is a method for solving a complex problem by breaking it down into simpler subproblems
    Dynamic programming is an optimization techniques for recursive solutions that have overlapping sub-problem, 
    we use dp to solve a sub-problem, we use dp to solve a sub-problem only sequence
    This type of algo uses memorization technique, it stores the previously calculated result to avoid calculating it again and again
Example: find n-th term of Fibonacci sequence
----------------------------
def fibonacci(n):                       int fibonacci(int n){               // find n-th term of a fibonacci sequence
  dp = [0]*(n+1)                            int dp[n+1] = {0};
  dp[0] = 0                                 dp[0]=0; dp[1]=1;
  dp[1] = 1                                 for(int i = 2; i<n; i++){
  for i in range(2, len(dp)):                   dp[i] = dp[i-1] + dp[i-2];
    dp[i] = dp[i-1] + dp[i-2]               }
  return dp[n]                              return dp[n];
                                        }
----------------------------
    - Longest Common Subsequence
    - Longest Increasing Subsequence
    - Edit Distance
    - Minimum Partition
    - Ways to Cover a Distance
    - Longest Path in Matrix
    - Subset Sum Problem
    - Optimal Strategy for a Game
    - 0-1 Knapsack Problem
    - Assembly Line Scheduling
    
      - it loses Space but earns Time  (by Bellman)
      It solves complex problems by breaking'em into multiple simple subproblems
      and then it solves each of them once and then stores them for future use.
      DP is an optimization techniques for recursive solutions 
      that have overlapping subproblems, we use dp to solve a subproblem only sequence.
      The components of a dynamic programming algorithmic solution?

      - Implement the Longest Common Subsequence algorithm to solve DNA
      - Decompose large problems using Dynamic Programming techniques
      - Apply Dynamic Programming techniques in the Longest Common Subsequence algorithm
      
      - Fibonacci Number Series
      - Sequence Alignment
      - Knapsack Problem
      - Tower of Hanoi Puzzle
      - Shortest Path by Dijkastra
      - Matrix Chain Multiplication
      - A type of Balanced 0-1 Matrix
      - CheckerBoard
      - Egg Dropping Puzzle





# ALGORITHM TECHNIQUES
# DIVIDE and CONQUER METHODOLOGY    (An Algorithm Design Paradigm)
    A Divide-and-Conquer algorithm recursively breaks down a problem into two or more sub-problems of the related type, 
    until these become simple enough to be solved directly
    An algorithm that first divides the problem into smaller parts and solve them, then combine to get final solution
    In this algo, a bigger problem is divided into subproblems of same type and solve independently.
    Finally the outputs from those subproblems are combined/conquered to give the actual output.
    An Algorithm that divides the problems in two/smaller parts 
    and then combined/added together to produce the problem's final solution

Example: Merge Sort
----------------------------
def merge_sort(arr):
  if len(arr) < 2:
    return arr
  else:
    mid = len(arr) // 2
    left_part = merge_sort(arr[:mid])
    right_part = merge_sort(arr[mid:])
    return join_sorted(left_part, right_part)
----------------------------    

Example: Binary Search
----------------------------
int findNum(int arr[], int key, int 5, int e){
    while(s <= e){
        int mid = (s+e)/2;
        if(arr[mid] == key)
            return mid;
        else if(arr[mid] < key)
            s = mid + 1;
        else
            e = mid - 1;
        }
        return -1;
    }    
----------------------------





# ALGORITHM TECHNIQUES
# GREEDY ALGORITHMS
    We find a locally optimum solution and hope to find the optimal solution at the global level.
    An algorithm that chooses the most optional move at each step (part by part)
    It always makes the choice that seems to be the best at that moment

    In this approach, decisions are taken on the basis of the information currently available without worrying about the future
    The approach doesn't relook at the previous chosen solution.
    The method tries to find/chooses the best/most (optimal) solution/move at each step.
    The first step is chosen in such a way that it gives immediate benefit.
    This Approach/These Algorithms are mainly used for solving optimization problems
    The method doesn't guarantee/provide that we will be able to find a optimal solution in many problems.
    However, the method gives near optimal solution in a reasonable time and it is efficient in many cases and easy to implement.
    Hence, Greedy Algorithm is an algorithmic paradigm which is based on inference
    Components of Greedy Algorithms:
    - Candidate State: The solution is created by this set
    - Selection Function: It's used to add the best candidate to the solution
    - Feasibility Function: It's used to determine whether the candidate can be used to contribute to the solution.
    - Objective Function: It's used to assign a value to a solution.
    - Solution Function: It's used to indicate whether a complete solution has been obtained


    - Huffman Coding (for a Huffman Tree)
    - Fractional Knapsack Problem
    - Activity Selection
    - Job Sequencing Problem
    - Travelling Salesman Problem
    - Decision Tree
    - Dijkstra's Algorithm (for Graph Search and Short Path Finding)
    - Kruskal's Algorithm (to construct a Minimum Spanning Tree)
    - Prim's Algorithm (to construct a Minimum Spanning Tree)

Example: Activity selection problem (Maximum number of activities infinite amount of time)
----------------------------
def max_nb_activities(activities, time_limit):
  activities.sort()
  count = 0
  time = 0
  for activity in activities:
    if (time + activity) > time_limit:
      break
    else:
      count += 1
      time += activity
    return
----------------------------








# BASIC ALGORITHMS
    - Huffman Coding Compression Algorithm
    - Euclid's Algorithm
    - Union Find Algorithm







# ALGORITHM TECHNIQUES
# RECURSIVE ALGORITHM
    An algorithm that calls itself repeatedly until the problem is solved
    In this algo, a problem is broken into subproblems of the same type and called again and again until the termination condition is reached. 

    - Factorial
    - Exponential
    - Tower of Hanoi
    - Tree Traversal
    - DFS of Graph

Example in CPP : To determine the sum of first n natural numbers
----------------------------                    Example: find factorial of given number num
int fact(int n)                                 int factorial(int num){             // find factorial of given number num
{                                                   if(n==0){
  if (n <= 1) // base case                              return 1;
    return 1;                                       }
  else                                              return n * factorial(n-1);
    return n * fact(n-1);                       }
}
----------------------------







# ALGORITHM TECHNIQUES
# BRUTE-FORCE SEARCH ALGORITHM          (Problem-Solving Technique, An Algo Paradigm)
    An algorithm that tries every/all possibilities available to solve a problem until a satisfactory solution is found
    This is the basic and most simplest type of algo.
    It is method of solving problem, 
    In this method every possibility is examined, trying all possible answers and picking the best one.
      
    Performance
    The time complexity of Brute Force is O(n*m) which is sometimes written as O(n*m)
    So, if we were to search for a string of n characters in a string of m characters using brute force, it would take us n * m tries.

Example: Native Algorithm to find a pair sums up to k (tries every possible layer)
----------------------------
def find_pair(arr, k):
  for i in range(len(arr)):
    for j in range(i+1, len(arr)):
      if (arr[i]+arr[j]) == k:
        return (i, j)
  return(-1, -1)
----------------------------

Example: Linear Search in C++
----------------------------
// return the index given key in the array of size n
int findNum(int arr[], int n, int key){
    for(int i = 0; i<n; i++){
        if(arr[i] == key){
            return i;
        }
    }    
    return -1;
}        
----------------------------
      

  
  






# ALGORITHM TECHNIQUES
# BACKTRACKING ALGORITHM
    An algorithm that tries all the possible candidate solutions using recursive method and goes back 
    as soon as it's defects that the actual candidate can't be valid
    and if solutions fails to satisfy its constraints then it returns to previous step and tries to explore other solutions.
    This algo prunes the recursion tree as per the need and strongly relies upon DO and UNDO transformation of the states. 
    A backtracking algorithm solves a subproblem, and if it fails to solve the problem,
    it undoes the last step and starts again to find the solution to the problem.
    
    Example: Rat in a maze, N queen problem

Example: Count subsets that sum up to k
----------------------------
def subsets_k(arr, k, i = 0)
  if k == 0:
    return 1 # valid candidate
  elif k < 0 or i == len(arr):
    return 0 # invalid candidate
  else:
    return subsets_k(arr[i], i+1) + subsets_k(arr, k, i+1)
----------------------------




# ALGORITHM TECHNIQUES
# Randomized Algorithm
      A randomized algorithm uses a random number at least once 
      during the computation to make a decision




# DATA STRUCTURES ALGORITHMS
    - Binary Indexed Tree or Fenwick Tree
    - Tries
    - Suffix Array
    - Suffix Automata
    - Suffix Automata II
    - Sparse Table
    - LCA and RMQ
    - Segment Tree (RMQ, Range Sum and Lazy Propagation)
    - K-D Tree (See Insert, Mınimum and Delete)
    - Union Find Disjoint Set



-- Number Theory and Other Mathematical Algorithms
# PRIME NUMBERS and PRIME FACTORIZATION ALGORITHMS
    - Sieve of Eratosthenes
    - Segmented Sieve
    - Wilson's Theorem
    - Prime Factorization
    - Pollard's Rho Algorithm
    - Primality test

# MODULO ARITHMETIC ALGORITHMS
    - Basic and Extended Euclidean Algorithms
    - Euler's Totient Function
    - Modular Exponentiation
    - Modular Multiplicative Inverse
    - Chinese Remainder Theorem Introduction
    - Chinese Remainder Theorem
    - Modulo Inverse Implementation

# GEOMETRICAL and NETWORK FLOW ALGORITHMS
    - Convex Hull
    - Graham Scan
    - Line Intersection
    - Interval Tree
    - Matrix Exponentiation 
    - Maxflow Ford Furkerson Algorithm
    - Edmond Karp Implementation
    - Stable Marriage Problem
    - Hopcropt-Karp Algorithm for Maximum Matching
    - Dinic's Algorithm and E-Maxx











What is an Algorithm?
  An algorithm is a set of step-by-step procedures, or a set of rules to follow, for completing a specific task or solving a particular problem.
  The word algorithm was first coined in the 9th century
  
  Algorithmic programming is all about writing a set of rules with a finite number of steps that instruct the computer how to perform a task
  A prog is essentially an algo that tells the computer what specific steps to execute, in what specific order, in order to carry out a specific task
  
  Types of Algorithms
    - Divide and Conquer Algorithms
    - Brute Fore Algorithms
    - Randomized Algorithms
    - Greedy Algorithms
    - Recursive Algorithms
    - Backtracking Algorithms
    - Dynamic Programming Algorithms
    
    Why are Algorithms Important to Understand?
      Algorithmic thinking allows students to break down problems and conceptualize solutions in terms of discrete steps
      

ARRAYS
Arrays are defined as the collection of elements of same data type
Array is the simpliest data structure where each data element can be randonly accessed by using its index number

--Array declaration in C language
Data_type array_name[size]
eg: int arr[10]

Array Memory representation
      0  1  2  3  --> index
      5 10 15 20  --> value
      
--Properties of Array
1. Each element is of same data type and carries a same size i.e. int = 4 bytes.
2. Elements of the array are stored at contiguous memory locations.
3. Elements of the array can be randomly accessed.

--Array Use Case
If we want to store price of 4 different pens
we use variables to store price like this
    price1 = 10
    price2 = 14
    price3 = 5
    price4 = 3

we could simply use an array to store these values
    int pen_price[10, 14, 5, 3]
If we want to access an element from this array, we could use its index number.

For example we can access the value "5" by using its index number "2" like this
    print(pen_price[2]) 

Example: to find out the output
    int mark1[10]
    int mark2[14]
    mark2 = [8, 25, 789, 4, 2, 7, 8, 9, 45, 78]
    mark1 = [1, 0, 2, 45, 85, 5, 8, 0]
    print(mark2[5])   # 7

TWO DIMENSIONAL ARRAY
Array of Arrays are called 2D array
The 2D array is organized as matrices which can be represented as the collection of rows amnd columns

2D Array declaration in C language
Data_type array_name[rows][columns]
eg: int arr[3][3]

2D Array representation(a[3][3])

      a[0][0]   a[0][1]   a[0][2]
